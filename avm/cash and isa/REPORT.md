| Лабораторная работа №4    | M3139                     | Архитектура ЭВМ |
| ------------------------- |---------------------------| ---- |
| Кэш и кодирование команд  | Хасанов Дмитрий Вадимович | 2024 |

# Расчёт параметров системы

Полученные параметры системы

| Параметр         | Значение (с единицами измерения) |
| ---------------- |----------------------------------|
| MEM_SIZE         | 512 Кбайт                        |
| ADDR_LEN         | 19 бит                           |
| CACHE_WAY        | 4                                |
| CACHE_TAG_LEN    | 10 бит                           |
| CACHE_INDEX_LEN  | 4 бита                           |
| CACHE_OFFSET_LEN | 5 битов                          |
| CACHE_SIZE       | 2 Кбайта                         |
| CACHE_LINE_SIZE  | 32 байта                         |
| CACHE_LINE_COUNT | 64                               |
| CACHE_SETS       | 16                               |

# Расчёт:

ADDR_LEN = log2(MEM_SIZE) = log2(512*1024) = 19 бит

CACHE_TAG_LEN = ADDR_LEN - CACHE_INDEX_LEN - CACHE_OFFSET_LEN = 19 - 4 - 5 = 10 бит

CACHE_LINE_SIZE = $2^{CACHE\\_OFFSET\\_LEN}$ = $2^5$ = 32 байта

CACHE_SETS = $2^{CACHE\\_INDEX\\_LEN}$ = $2^4$ = 16 блоков

CACHE_LINE_COUNT = CACHE_SIZE / CACHE_LINE_SIZE = 2*1024 / 32 = 64 строки

CACHE_WAY = CACHE_LINE_COUNT / CACHE_SETS = 64 / 16 = 4


# Структура кэш-линии

В данной лабораторной работе было необходимо смоделировать работу процессора и кэша при выполнении кода на RISC-V с политиками вытеснения LRU и bit-pLRU.

В кеш-линии я храню записана ли в ней какая-нибудь информация или ещё нет, информацию об адресе данных, которые в ней сохранены, а также MRU-бит, если политика bit-pLRU или таймер (время, когда она была последний раз использована), если политика LRU.

Длина кеш-линии 32 байта; кеш-линии хранятся в блоках по 4 штуки, ведь ассоциативность равна 4, всего блоков в кеше 16.

32 регистра храню как вектор интов.

# Политики вытеснения

LRU:

Для каждой кеш-линии хранится таймер (время её последнего использования), при кеш-промахе перезаписывается линия, счётчик которой самый маленький (т.е. линия не использовалась дольше всего).

pLRU:

Bit-PLRU хранит один статусный бит для каждой строки кэша. Если он равняется 1, мы считаем, что строка недавно использовалась. Когда биты всех линий станут 1, мы меняем значения всех на 0, кроме последней кеш-линии, к которой было обращение. При кеш-промахе перебираем кеш-линии последовательно (по возрастанию индекса), и в первую, значащий бит, которой равен 0, записываем значение.

# Перевод команд в машинный код

Все команды разбиты на группы, внутри каждой из которых команды имеют похожий вид перевода из asm ода в машинный, с точностью до замены opcode, funct3, funct7. Во всех командах присутствует opcode и во многих funct3, поэтому мной были созданы мапы, в которых каждой команде были сопоставлены значения для неё. Были реализованы проверки корректности подаваемых данных (для констант проверялось, что они либо десятичные, либо шестнадцатеричные; для регистров проверялось, что такой регистр существует). Результатом парсинга была двоичная строка длины 32, которая передавалась в функцию parser, для перевода её в 4 байта машинного кода и сохранения их для дальнейшего вывода в файл (в нём проверялось, что переданная строка действительно имеет длину 32, т.е. кодирует 4 байта информации).

# Исполнение команд

Мы храним глобальный счётчик PROGRAM_COUNTER, который указывает в каком месте в памяти мы сейчас находимся (изначально равен 0x10000). Мы продолжаем выполнять команды до тех пока этот указатель не станет указывать на память до начального состояния (0x10000), либо пока не будет указывать на память за пределами всех команд (т.е. изначальная позиция и 4*количество команд, ведь каждая команда занимает по 4 байта). Зная текущий адрес в памяти мы пересчитываем кеш-попадания (функции update_lru и update_plru), после чего в функции operation я реализовал их исполнение. Команды можно поделить на два типа, обращиющиеся к памяти (кешу) и нет, в тех которые обращаются я также пересчитываю кеш-попадания.

# Вывод данных

От нас требовалось выводить машинный код в файл, переданный через аргументы командной строки. А кеш попадания необходимо выводить в стандартный поток вывода (разделяя кеш-попадания для команд, данных и общий). В случае если нам не был передан какой-то из файлов (входной иил выходной) мы завершаем программу.

# Внесённые изменения

Раньше был реализован только look-through: сначала за линию от размера кеш-блока проверялось попадание в кеш, и только при промахе (согласно политике вытеснения) мы меняли кеш.
Теперь добавлена конфигурация write-back: в своей реализации я не храню внутри кеша память (этого не требовалось в явном виде), поэтому для write-back я храню только dirty бит для каждой кеш линии, который выставляю в значение true, только когда меняю память в кеше, т.е. только при исполнении команд sb, sh и sw, в остальных случаях данные в кеше не изменяются, поэтому dirty бит остаётся в значение false (по факту, в данной реализации я сразу записывал изменения в оперативку).

В main-е была исправлена ошибка, из-за которой программа обращалась по не правильному адресу в памяти, чтобы получить команду. 
Исправлены ошибки при переводе из asm кода. 
Исправлены ошибки при исполнении инструкций.
Добавлена поддержка инструкций ecall и ebreak (которая была случайно забыта ранее).

Изначально все регистры проинициализированы 0 (zero зануляю после каждой команды), для ra это корректное значение, ведь этот адрес лежит за пределами нашей памяти, которая начинается с 0х10000.

# Самописный asm код

Требовалось написать на ассемблере RISC-V фрагмент кода, имеющий процент попаданий 96% и 37,5% хотя бы по одной из политик вытеснения, причём чтобы было хотя бы одно вытеснение из кэша. 

Начнём с вытеснения: на offset и index в кэше отводиться 9 бит, поэтому если мы хотим иметь адреса в кэше, которые не будут лежать в одной кэш-строке и будут иметь один и тот же индекс кэш-блока (т.е. способные вытеснять друг-друга), нам достаточно брать адреса отличающиеся на 512 (тогда у таких адресов будет равный offset и index, но разные tag-и). Ассоциативность равна 4, поэтому, чтобы произошло вытеснение из кэша нам нужно хотя бы 5 кэш-строк, которые должны быть в одном блоке. Инструкции sh gp, 0, a0; sw gp, 512, a5; sh gp, 1024, a6; sw gp, 1536, a7  берут данные из памяти, причём (по описанным ранее причинам) имеют разные теги и лежат в одном кэш блоке (теги 0, 1, 2 и 3 и index = offset = 0), их уже 4 штуки, но самой первой инструкцией была lui gp, 1, лежащая в памяти по адресу 0x10000, имеет тег 128 и index = offset = 0, а значин она также лежит в том кэш-блоке. Это гарантирует, что в обоих политиках вытеснения при исполнении инструкции sw gp, 1536, a7 произойдёт вытеснение из кэша.

37,5% попаданий по данным, это 3/8. sh gp, 0, a0 будет промахом, ведь в кэше не будет строки с тегом равном 1. sb gp, 1, a1; sw gp, 2, a2; sh gp, 16, a3 будут попаданиями, ведь будут иметь тег = 0 и находиться в той же кэш-строке, что первые данные (длина кеш строки 32). Все следующие команды с памятью будут промахами, sb gp, 32, a4 будет иметь индекс 1 и тег 0, поэтому в кэше не будет данных с таким адресом, а три оставшиеся команды будут иметь теги 1, 2 и 3 из-за чего для них так же не будет данных в кэше.

96% попаданий по инструкциям, в моём случае это 72/75. У нас всего 75 инструкций (для удобства они были разделены на блоки пустыми строками). Первые три блока имеют суммарно 13 команд, причём каждая из них будет выполнена единожды. Оставшиеся 7 команд будут исполнены 9 раз (кроме самой последней она 8), итого получаем 13+7*9-1 = 75 команд. В данном наборе инструкций последние 7 будут исполняться несколько раз, потому что в начале (с помощью addi gp, sp, 9) присвоили регистру gp значение 9; beq t5, t6, -24 : уменьшает PROGRAM_COUNTER на 24 каждый раз (потому что значения в регистрах t5 и t6 всегда равны, мы их не изменяем и в них лежат 0), это уменьшение отправляет нас на 6 команд назад, т.е. на ori s10, s11, 12, таким образом мы перебираем инструкции блоком из 7 штук. addi sp, s1, 1 и addi s1, sp, 0 сначала присваивают в sp = s1+1, а после s1 = sp+0, таким образом значение регистра sp на каждом проходе этого "цикла" инструкций увеличивается на 1. beq gp, sp, -1024 завершит выполнение команд (всего 20 инструкций, значит в любой момент времени PROGRAM_COUNTER не превосходит 0х10000 более чем на 4*(20-1) = 76, а 1024 > 76, значит после вычитания мы окажемся за пределами отведённой нам памяти; можно утверждать, что PROGRAM_COUNTER не превосходит данного значения, потому что в наборе нет инструкции увеличивающей PROGRAM_COUNTER не на 4, кроме beq t5, t6, -24, которая по циклу исполняет инструкции и beq gp, sp, -1024, которая завершает этот цикл); beq gp, sp, -1024 уменьшит PROGRAM_COUNTER только если значения в регистрах совпадут, gp мы присвоили 9, а sp увеличивается на 1 после каждой итерации цикла (что и даст нам 9 итераций цикла инструкций).

Значит у нас всего будет исполнено 75 инструкций, осталось добиться 72 кэш-попаданий. Всего инструкций - 20, длина кэш-строки - 32, одна инструкция занимает 4, значит в одной строке хранится 8 инструкций, откуда мы понимаем, что на 20 инструкций требуется 3 кэш-строки, а значит будет три промаха (при обработке 1 инструкции, 9 и первой обработке 17). Они все будут иметь тег 128, и иметь индексы от 0 до 2.
